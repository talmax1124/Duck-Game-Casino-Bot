[
    {
        "label": "discord",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "discord",
        "description": "discord",
        "detail": "discord",
        "documentation": {}
    },
    {
        "label": "View",
        "importPath": "discord.ui",
        "description": "discord.ui",
        "isExtraImport": true,
        "detail": "discord.ui",
        "documentation": {}
    },
    {
        "label": "Button",
        "importPath": "discord.ui",
        "description": "discord.ui",
        "isExtraImport": true,
        "detail": "discord.ui",
        "documentation": {}
    },
    {
        "label": "Button",
        "importPath": "discord.ui",
        "description": "discord.ui",
        "isExtraImport": true,
        "detail": "discord.ui",
        "documentation": {}
    },
    {
        "label": "commands",
        "importPath": "discord.ext",
        "description": "discord.ext",
        "isExtraImport": true,
        "detail": "discord.ext",
        "documentation": {}
    },
    {
        "label": "commands",
        "importPath": "discord.ext",
        "description": "discord.ext",
        "isExtraImport": true,
        "detail": "discord.ext",
        "documentation": {}
    },
    {
        "label": "commands",
        "importPath": "discord.ext",
        "description": "discord.ext",
        "isExtraImport": true,
        "detail": "discord.ext",
        "documentation": {}
    },
    {
        "label": "Cog",
        "importPath": "discord.ext.commands",
        "description": "discord.ext.commands",
        "isExtraImport": true,
        "detail": "discord.ext.commands",
        "documentation": {}
    },
    {
        "label": "Context",
        "importPath": "discord.ext.commands",
        "description": "discord.ext.commands",
        "isExtraImport": true,
        "detail": "discord.ext.commands",
        "documentation": {}
    },
    {
        "label": "generate_duck_game_image",
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "isExtraImport": true,
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "upload_frame_and_get_url",
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "isExtraImport": true,
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "get_secure_hazard",
        "importPath": "utils.rng",
        "description": "utils.rng",
        "isExtraImport": true,
        "detail": "utils.rng",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "secrets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "secrets",
        "description": "secrets",
        "detail": "secrets",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "ModeSelectView",
        "kind": 6,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "class ModeSelectView(View):\n    \"\"\"Mode picker for Easy/Medium/Hard; transitions to the live game view.\"\"\"\n    def __init__(self, user, amount, wallet_after, username):\n        super().__init__(timeout=None)\n        self.user = user\n        self.amount = float(amount)\n        self.wallet_after = wallet_after\n        self.wallet_before = float(wallet_after) + float(amount)\n        self.username = username\n        self.started = False  # prevent multiple sessions from the same mode panel",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "DuckGameView",
        "kind": 6,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "class DuckGameView(View):\n    \"\"\"Live game view with Forward/Stop; edits a single message in place.\"\"\"\n    def __init__(\n        self,\n        user,\n        amount,\n        wallet_before,\n        wallet_after,\n        multiplier,\n        username,",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "LeaderboardView",
        "kind": 6,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "class LeaderboardView(View):\n    def __init__(self, ctx: Context, pages: list[list[tuple[int, int, str]]]):\n        super().__init__(timeout=120)\n        self.ctx = ctx\n        self.pages = pages\n        self.index = 0\n        self.prev_btn = Button(label=\"Prev\", style=discord.ButtonStyle.secondary)\n        self.next_btn = Button(label=\"Next\", style=discord.ButtonStyle.secondary)\n        self.prev_btn.callback = self._prev\n        self.next_btn.callback = self._next",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "DuckGame",
        "kind": 6,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "class DuckGame(Cog):\n    def __init__(self, bot):\n        self.bot = bot\n        self.active_sessions = set()\n    @commands.command(name=\"testduck\", help=\"Generate a sample Duck Game board image for testing.\")\n    async def testduck_command(self, ctx: Context, lanes: int = 5):\n        \"\"\"Quick sanity check: renders a board with the duck in grass and no hazards.\n        Usage: !testduck [lanes]\n        \"\"\"\n        try:",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "fmt",
        "kind": 2,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "def fmt(amount: float) -> str:\n    try:\n        return f\"${float(amount):,.2f}\"\n    except Exception:\n        return f\"${amount}\"\ndef fmt_delta(after: float, before: float) -> str:\n    try:\n        delta = float(after) - float(before)\n        sign = \"+\" if delta >= 0 else \"-\"\n        return f\"({sign}{abs(delta):,.2f})\"",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "fmt_delta",
        "kind": 2,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "def fmt_delta(after: float, before: float) -> str:\n    try:\n        delta = float(after) - float(before)\n        sign = \"+\" if delta >= 0 else \"-\"\n        return f\"({sign}{abs(delta):,.2f})\"\n    except Exception:\n        return \"\"\n# --- Colored delta formatting -------------------------------------------------\ndef fmt_delta_colored(after: float, before: float) -> str:\n    try:",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "fmt_delta_colored",
        "kind": 2,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "def fmt_delta_colored(after: float, before: float) -> str:\n    try:\n        delta = float(after) - float(before)\n        if delta >= 0:\n            return f\"ðŸŸ¢ (+${delta:,.2f})\"\n        else:\n            return f\"ðŸ”´ (-${abs(delta):,.2f})\"\n    except Exception:\n        return \"\"\n# --- Interaction ACK helper --------------------------------------------------",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "load_bank",
        "kind": 2,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "def load_bank():\n    if not os.path.exists(\"data/bank.json\"):\n        return {}\n    try:\n        with open(\"data/bank.json\", \"r\") as f:\n            data = json.load(f)\n    except Exception:\n        # If file is corrupt/empty, fall back to empty\n        return {}\n    # Ensure all users have wallet, bank, game_active, last_earn_ts keys",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "update_bank",
        "kind": 2,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "def update_bank(data):\n    # Atomic write to avoid corruption on crashes\n    os.makedirs(\"data\", exist_ok=True)\n    _atomic_write_json(\"data/bank.json\", data)\n# -------------------- MODE SELECTION VIEW --------------------\nclass ModeSelectView(View):\n    \"\"\"Mode picker for Easy/Medium/Hard; transitions to the live game view.\"\"\"\n    def __init__(self, user, amount, wallet_after, username):\n        super().__init__(timeout=None)\n        self.user = user",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "EARN_AMOUNT",
        "kind": 5,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "EARN_AMOUNT = 20_000.0\nCOOLDOWN_SECONDS = 3600.0\nimport discord\nfrom discord.ui import View, Button\nfrom discord.ext import commands\nfrom discord.ext.commands import Cog\nfrom discord.ext.commands import Context\nfrom utils.image_generator import generate_duck_game_image, upload_frame_and_get_url\nfrom utils.rng import get_secure_hazard\nimport io",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "COOLDOWN_SECONDS",
        "kind": 5,
        "importPath": "commands.duckgame",
        "description": "commands.duckgame",
        "peekOfCode": "COOLDOWN_SECONDS = 3600.0\nimport discord\nfrom discord.ui import View, Button\nfrom discord.ext import commands\nfrom discord.ext.commands import Cog\nfrom discord.ext.commands import Context\nfrom utils.image_generator import generate_duck_game_image, upload_frame_and_get_url\nfrom utils.rng import get_secure_hazard\nimport io\nimport json",
        "detail": "commands.duckgame",
        "documentation": {}
    },
    {
        "label": "get_duck_visual",
        "kind": 2,
        "importPath": "utils.assets",
        "description": "utils.assets",
        "peekOfCode": "def get_duck_visual(\n    position: int,\n    max_length: int = 5,\n    *,\n    hazard_pos: int = -1,\n    show_hazard: bool = True,\n    labels: Optional[List[str]] = None,\n    base_width: int = 100,\n    duck_scale: float = 1.0,\n    car_scale: float = 1.0,",
        "detail": "utils.assets",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "utils.assets",
        "description": "utils.assets",
        "peekOfCode": "BASE_DIR = os.path.dirname(os.path.abspath(__file__))\nASSETS_DIR = os.path.join(BASE_DIR, \"..\", \"assets\")\nROAD_DIR = os.path.join(ASSETS_DIR, \"road\")\nDUCK_DIR = os.path.join(ASSETS_DIR, \"duck_images\")\nOUTPUT_DIR = os.path.join(ASSETS_DIR, \"output\")\n# Simple image cache to avoid reloading from disk repeatedly\n_IMG_CACHE = {}\ndef _load_img(path: str) -> Image.Image:\n    abspath = os.path.abspath(path)\n    if abspath in _IMG_CACHE:",
        "detail": "utils.assets",
        "documentation": {}
    },
    {
        "label": "ASSETS_DIR",
        "kind": 5,
        "importPath": "utils.assets",
        "description": "utils.assets",
        "peekOfCode": "ASSETS_DIR = os.path.join(BASE_DIR, \"..\", \"assets\")\nROAD_DIR = os.path.join(ASSETS_DIR, \"road\")\nDUCK_DIR = os.path.join(ASSETS_DIR, \"duck_images\")\nOUTPUT_DIR = os.path.join(ASSETS_DIR, \"output\")\n# Simple image cache to avoid reloading from disk repeatedly\n_IMG_CACHE = {}\ndef _load_img(path: str) -> Image.Image:\n    abspath = os.path.abspath(path)\n    if abspath in _IMG_CACHE:\n        return _IMG_CACHE[abspath]",
        "detail": "utils.assets",
        "documentation": {}
    },
    {
        "label": "ROAD_DIR",
        "kind": 5,
        "importPath": "utils.assets",
        "description": "utils.assets",
        "peekOfCode": "ROAD_DIR = os.path.join(ASSETS_DIR, \"road\")\nDUCK_DIR = os.path.join(ASSETS_DIR, \"duck_images\")\nOUTPUT_DIR = os.path.join(ASSETS_DIR, \"output\")\n# Simple image cache to avoid reloading from disk repeatedly\n_IMG_CACHE = {}\ndef _load_img(path: str) -> Image.Image:\n    abspath = os.path.abspath(path)\n    if abspath in _IMG_CACHE:\n        return _IMG_CACHE[abspath]\n    img = Image.open(abspath).convert(\"RGBA\")",
        "detail": "utils.assets",
        "documentation": {}
    },
    {
        "label": "DUCK_DIR",
        "kind": 5,
        "importPath": "utils.assets",
        "description": "utils.assets",
        "peekOfCode": "DUCK_DIR = os.path.join(ASSETS_DIR, \"duck_images\")\nOUTPUT_DIR = os.path.join(ASSETS_DIR, \"output\")\n# Simple image cache to avoid reloading from disk repeatedly\n_IMG_CACHE = {}\ndef _load_img(path: str) -> Image.Image:\n    abspath = os.path.abspath(path)\n    if abspath in _IMG_CACHE:\n        return _IMG_CACHE[abspath]\n    img = Image.open(abspath).convert(\"RGBA\")\n    _IMG_CACHE[abspath] = img",
        "detail": "utils.assets",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "kind": 5,
        "importPath": "utils.assets",
        "description": "utils.assets",
        "peekOfCode": "OUTPUT_DIR = os.path.join(ASSETS_DIR, \"output\")\n# Simple image cache to avoid reloading from disk repeatedly\n_IMG_CACHE = {}\ndef _load_img(path: str) -> Image.Image:\n    abspath = os.path.abspath(path)\n    if abspath in _IMG_CACHE:\n        return _IMG_CACHE[abspath]\n    img = Image.open(abspath).convert(\"RGBA\")\n    _IMG_CACHE[abspath] = img\n    return img",
        "detail": "utils.assets",
        "documentation": {}
    },
    {
        "label": "_IMG_CACHE",
        "kind": 5,
        "importPath": "utils.assets",
        "description": "utils.assets",
        "peekOfCode": "_IMG_CACHE = {}\ndef _load_img(path: str) -> Image.Image:\n    abspath = os.path.abspath(path)\n    if abspath in _IMG_CACHE:\n        return _IMG_CACHE[abspath]\n    img = Image.open(abspath).convert(\"RGBA\")\n    _IMG_CACHE[abspath] = img\n    return img\ndef get_duck_visual(\n    position: int,",
        "detail": "utils.assets",
        "documentation": {}
    },
    {
        "label": "load_bank",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def load_bank() -> dict:\n    _ensure_dir_and_file()\n    with _LOCK:\n        try:\n            with open(BANK_FILE, \"r\") as f:\n                data = json.load(f)\n                return data if isinstance(data, dict) else {}\n        except Exception:\n            return {}\ndef save_bank(bank: dict) -> None:",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "save_bank",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def save_bank(bank: dict) -> None:\n    _ensure_dir_and_file()\n    with _LOCK:\n        _atomic_write_json(BANK_FILE, bank)\n# ----------------------------- schema helpers --------------------------------\ndef _ensure_user(bank: dict, uid: str) -> dict:\n    if uid not in bank or not isinstance(bank[uid], dict):\n        bank[uid] = dict(_DEFAULT_USER)\n    # Fill any missing keys (forward compatible)\n    for k, v in _DEFAULT_USER.items():",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "get_balances",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def get_balances(user_id) -> Tuple[float, float]:\n    \"\"\"Return (wallet, bank) for the user, creating a default record if needed.\"\"\"\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        save_bank(data)\n        return float(rec[\"wallet\"]), float(rec[\"bank\"])\ndef set_balances(user_id, *, wallet: Optional[float] = None, bank: Optional[float] = None) -> Tuple[float, float]:\n    \"\"\"Set wallet and/or bank (clamped to >= 0). Returns (wallet, bank).\"\"\"",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "set_balances",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def set_balances(user_id, *, wallet: Optional[float] = None, bank: Optional[float] = None) -> Tuple[float, float]:\n    \"\"\"Set wallet and/or bank (clamped to >= 0). Returns (wallet, bank).\"\"\"\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        if wallet is not None:\n            rec[\"wallet\"] = max(0.0, float(wallet))\n        if bank is not None:\n            rec[\"bank\"] = max(0.0, float(bank))",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "adjust_wallet",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def adjust_wallet(user_id, delta: float, *, floor: float = 0.0) -> Tuple[bool, float]:\n    \"\"\"Add `delta` to wallet. If result < floor, abort and return (False, current).\"\"\"\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        cur = float(rec[\"wallet\"])\n        new_val = cur + float(delta)\n        if new_val < float(floor):\n            return False, cur",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "adjust_bank",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def adjust_bank(user_id, delta: float, *, floor: float = 0.0) -> Tuple[bool, float]:\n    \"\"\"Add `delta` to bank. If result < floor, abort and return (False, current).\"\"\"\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        cur = float(rec[\"bank\"])\n        new_val = cur + float(delta)\n        if new_val < float(floor):\n            return False, cur",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "move_wallet_to_bank",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def move_wallet_to_bank(user_id, amount: float) -> bool:\n    \"\"\"Transfer `amount` from wallet to bank. Returns True on success.\"\"\"\n    if amount <= 0:\n        return False\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        if rec[\"wallet\"] < amount:\n            return False",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "move_bank_to_wallet",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def move_bank_to_wallet(user_id, amount: float) -> bool:\n    \"\"\"Transfer `amount` from bank to wallet. Returns True on success.\"\"\"\n    if amount <= 0:\n        return False\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        if rec[\"bank\"] < amount:\n            return False",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "set_game_active",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def set_game_active(user_id, active: bool) -> None:\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        rec[\"game_active\"] = bool(active)\n        save_bank(data)\ndef get_game_active(user_id) -> bool:\n    uid = str(user_id)\n    with _LOCK:",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "get_game_active",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def get_game_active(user_id) -> bool:\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        save_bank(data)\n        return bool(rec.get(\"game_active\", False))\ndef get_last_earn_ts(user_id) -> float:\n    uid = str(user_id)\n    with _LOCK:",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "get_last_earn_ts",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def get_last_earn_ts(user_id) -> float:\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        save_bank(data)\n        return float(rec.get(\"last_earn_ts\", 0.0))\ndef set_last_earn_ts(user_id, ts: Optional[float] = None) -> None:\n    uid = str(user_id)\n    ts = time.time() if ts is None else float(ts)",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "set_last_earn_ts",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def set_last_earn_ts(user_id, ts: Optional[float] = None) -> None:\n    uid = str(user_id)\n    ts = time.time() if ts is None else float(ts)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        rec[\"last_earn_ts\"] = ts\n        save_bank(data)\ndef get_last_rob_ts(user_id) -> float:\n    uid = str(user_id)",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "get_last_rob_ts",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def get_last_rob_ts(user_id) -> float:\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        save_bank(data)\n        return float(rec.get(\"last_rob_ts\", 0.0))\ndef set_last_rob_ts(user_id, ts: Optional[float] = None) -> None:\n    uid = str(user_id)\n    ts = time.time() if ts is None else float(ts)",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "set_last_rob_ts",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def set_last_rob_ts(user_id, ts: Optional[float] = None) -> None:\n    uid = str(user_id)\n    ts = time.time() if ts is None else float(ts)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        rec[\"last_rob_ts\"] = ts\n        save_bank(data)\n# ----------------------------- win/loss stats ---------------------------------\ndef get_stats(user_id) -> Tuple[int, int]:",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "get_stats",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def get_stats(user_id) -> Tuple[int, int]:\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        save_bank(data)\n        return int(rec.get(\"wins\", 0)), int(rec.get(\"losses\", 0))\ndef increment_win(user_id) -> Tuple[int, int]:\n    uid = str(user_id)\n    with _LOCK:",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "increment_win",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def increment_win(user_id) -> Tuple[int, int]:\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        rec[\"wins\"] = int(rec.get(\"wins\", 0)) + 1\n        save_bank(data)\n        return int(rec[\"wins\"]), int(rec.get(\"losses\", 0))\ndef increment_loss(user_id) -> Tuple[int, int]:\n    uid = str(user_id)",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "increment_loss",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def increment_loss(user_id) -> Tuple[int, int]:\n    uid = str(user_id)\n    with _LOCK:\n        data = load_bank()\n        rec = _ensure_user(data, uid)\n        rec[\"losses\"] = int(rec.get(\"losses\", 0)) + 1\n        save_bank(data)\n        return int(rec.get(\"wins\", 0)), int(rec[\"losses\"])\ndef get_all_stats() -> Dict[str, Dict[str, int]]:\n    \"\"\"Return mapping of user_id -> {wins, losses}.\"\"\"",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "get_all_stats",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def get_all_stats() -> Dict[str, Dict[str, int]]:\n    \"\"\"Return mapping of user_id -> {wins, losses}.\"\"\"\n    with _LOCK:\n        data = load_bank()\n        for uid in list(data.keys()):\n            _ensure_user(data, uid)\n        save_bank(data)\n        out: Dict[str, Dict[str, int]] = {}\n        for uid, rec in data.items():\n            if not isinstance(rec, dict):",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "get_balance",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def get_balance(user_id) -> float:\n    wallet, _ = get_balances(user_id)\n    return wallet\ndef set_balance(user_id, new_amount: float) -> None:\n    set_balances(user_id, wallet=new_amount)\ndef update_balance(user_id, amount: float, *, allow_negative: bool = False, floor: float = 0.0) -> Tuple[bool, float]:\n    floor_val = float(floor) if not allow_negative else float(\"-inf\")\n    ok, new_wallet = adjust_wallet(user_id, amount, floor=floor_val)\n    return ok, new_wallet",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "set_balance",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def set_balance(user_id, new_amount: float) -> None:\n    set_balances(user_id, wallet=new_amount)\ndef update_balance(user_id, amount: float, *, allow_negative: bool = False, floor: float = 0.0) -> Tuple[bool, float]:\n    floor_val = float(floor) if not allow_negative else float(\"-inf\")\n    ok, new_wallet = adjust_wallet(user_id, amount, floor=floor_val)\n    return ok, new_wallet",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "update_balance",
        "kind": 2,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "def update_balance(user_id, amount: float, *, allow_negative: bool = False, floor: float = 0.0) -> Tuple[bool, float]:\n    floor_val = float(floor) if not allow_negative else float(\"-inf\")\n    ok, new_wallet = adjust_wallet(user_id, amount, floor=floor_val)\n    return ok, new_wallet",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "BANK_FILE",
        "kind": 5,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "BANK_FILE = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"data\", \"bank.json\"))\n# Default per-user record\n_DEFAULT_USER: Dict[str, float | bool | int] = {\n    \"wallet\": 1000.0,\n    \"bank\": 0.0,\n    \"game_active\": False,\n    \"last_earn_ts\": 0.0,\n    \"last_rob_ts\": 0.0,\n    \"wins\": 0,\n    \"losses\": 0,",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "_LOCK",
        "kind": 5,
        "importPath": "utils.bank",
        "description": "utils.bank",
        "peekOfCode": "_LOCK = threading.RLock()\n# ----------------------------- low-level I/O ---------------------------------\ndef _ensure_dir_and_file():\n    os.makedirs(os.path.dirname(BANK_FILE) or \".\", exist_ok=True)\n    if not os.path.exists(BANK_FILE):\n        with open(BANK_FILE, \"w\") as f:\n            json.dump({}, f)\ndef _atomic_write_json(path: str, data: dict):\n    tmp_path = path + \".tmp\"\n    with open(tmp_path, \"w\") as f:",
        "detail": "utils.bank",
        "documentation": {}
    },
    {
        "label": "generate_duck_game_image",
        "kind": 2,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "def generate_duck_game_image(\n    position: int,\n    hazard_pos: int,\n    previous_positions: Iterable[int],\n    total_slots: int,\n) -> Image.Image:\n    \"\"\"Render the board as a single image.\n    Columns (left to right):\n      - grass (start, virtual index -1)\n      - regular lanes 0..total_slots-1",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "IMAGE_CDN_CHANNEL_ID",
        "kind": 5,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "IMAGE_CDN_CHANNEL_ID = int(os.getenv(\"IMAGE_CDN_CHANNEL_ID\", \"0\"))\nASSETS_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), \"assets\")\nROAD_DIR = os.path.join(ASSETS_DIR, \"road\")\nDUCK_DIR = os.path.join(ASSETS_DIR, \"duck_images\")\nGRASS_PATH = os.path.join(ROAD_DIR, \"Grass.png\")\nLANE_PATH = os.path.join(ROAD_DIR, \"road.png\")\nEND_PATH = os.path.join(ROAD_DIR, \"end.png\")  # finish lane image\nCAR_PATH = os.path.join(ROAD_DIR, \"car.png\")\nDUCK_PATH = os.path.join(DUCK_DIR, \"duck.png\")\n# Fallback sizes in case assets are missing",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "ASSETS_DIR",
        "kind": 5,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "ASSETS_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), \"assets\")\nROAD_DIR = os.path.join(ASSETS_DIR, \"road\")\nDUCK_DIR = os.path.join(ASSETS_DIR, \"duck_images\")\nGRASS_PATH = os.path.join(ROAD_DIR, \"Grass.png\")\nLANE_PATH = os.path.join(ROAD_DIR, \"road.png\")\nEND_PATH = os.path.join(ROAD_DIR, \"end.png\")  # finish lane image\nCAR_PATH = os.path.join(ROAD_DIR, \"car.png\")\nDUCK_PATH = os.path.join(DUCK_DIR, \"duck.png\")\n# Fallback sizes in case assets are missing\nDEFAULT_TILE_W, DEFAULT_TILE_H = 256, 256",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "ROAD_DIR",
        "kind": 5,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "ROAD_DIR = os.path.join(ASSETS_DIR, \"road\")\nDUCK_DIR = os.path.join(ASSETS_DIR, \"duck_images\")\nGRASS_PATH = os.path.join(ROAD_DIR, \"Grass.png\")\nLANE_PATH = os.path.join(ROAD_DIR, \"road.png\")\nEND_PATH = os.path.join(ROAD_DIR, \"end.png\")  # finish lane image\nCAR_PATH = os.path.join(ROAD_DIR, \"car.png\")\nDUCK_PATH = os.path.join(DUCK_DIR, \"duck.png\")\n# Fallback sizes in case assets are missing\nDEFAULT_TILE_W, DEFAULT_TILE_H = 256, 256\n# ---------------------------------------------------------------------------",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "DUCK_DIR",
        "kind": 5,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "DUCK_DIR = os.path.join(ASSETS_DIR, \"duck_images\")\nGRASS_PATH = os.path.join(ROAD_DIR, \"Grass.png\")\nLANE_PATH = os.path.join(ROAD_DIR, \"road.png\")\nEND_PATH = os.path.join(ROAD_DIR, \"end.png\")  # finish lane image\nCAR_PATH = os.path.join(ROAD_DIR, \"car.png\")\nDUCK_PATH = os.path.join(DUCK_DIR, \"duck.png\")\n# Fallback sizes in case assets are missing\nDEFAULT_TILE_W, DEFAULT_TILE_H = 256, 256\n# ---------------------------------------------------------------------------\n# Image CDN helper (uploads a PIL image to a private channel and returns URL)",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "GRASS_PATH",
        "kind": 5,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "GRASS_PATH = os.path.join(ROAD_DIR, \"Grass.png\")\nLANE_PATH = os.path.join(ROAD_DIR, \"road.png\")\nEND_PATH = os.path.join(ROAD_DIR, \"end.png\")  # finish lane image\nCAR_PATH = os.path.join(ROAD_DIR, \"car.png\")\nDUCK_PATH = os.path.join(DUCK_DIR, \"duck.png\")\n# Fallback sizes in case assets are missing\nDEFAULT_TILE_W, DEFAULT_TILE_H = 256, 256\n# ---------------------------------------------------------------------------\n# Image CDN helper (uploads a PIL image to a private channel and returns URL)\n# ---------------------------------------------------------------------------",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "LANE_PATH",
        "kind": 5,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "LANE_PATH = os.path.join(ROAD_DIR, \"road.png\")\nEND_PATH = os.path.join(ROAD_DIR, \"end.png\")  # finish lane image\nCAR_PATH = os.path.join(ROAD_DIR, \"car.png\")\nDUCK_PATH = os.path.join(DUCK_DIR, \"duck.png\")\n# Fallback sizes in case assets are missing\nDEFAULT_TILE_W, DEFAULT_TILE_H = 256, 256\n# ---------------------------------------------------------------------------\n# Image CDN helper (uploads a PIL image to a private channel and returns URL)\n# ---------------------------------------------------------------------------\nasync def upload_frame_and_get_url(",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "END_PATH",
        "kind": 5,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "END_PATH = os.path.join(ROAD_DIR, \"end.png\")  # finish lane image\nCAR_PATH = os.path.join(ROAD_DIR, \"car.png\")\nDUCK_PATH = os.path.join(DUCK_DIR, \"duck.png\")\n# Fallback sizes in case assets are missing\nDEFAULT_TILE_W, DEFAULT_TILE_H = 256, 256\n# ---------------------------------------------------------------------------\n# Image CDN helper (uploads a PIL image to a private channel and returns URL)\n# ---------------------------------------------------------------------------\nasync def upload_frame_and_get_url(\n    bot: commands.Bot,",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "CAR_PATH",
        "kind": 5,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "CAR_PATH = os.path.join(ROAD_DIR, \"car.png\")\nDUCK_PATH = os.path.join(DUCK_DIR, \"duck.png\")\n# Fallback sizes in case assets are missing\nDEFAULT_TILE_W, DEFAULT_TILE_H = 256, 256\n# ---------------------------------------------------------------------------\n# Image CDN helper (uploads a PIL image to a private channel and returns URL)\n# ---------------------------------------------------------------------------\nasync def upload_frame_and_get_url(\n    bot: commands.Bot,\n    pil_img: Image.Image,",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "DUCK_PATH",
        "kind": 5,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "DUCK_PATH = os.path.join(DUCK_DIR, \"duck.png\")\n# Fallback sizes in case assets are missing\nDEFAULT_TILE_W, DEFAULT_TILE_H = 256, 256\n# ---------------------------------------------------------------------------\n# Image CDN helper (uploads a PIL image to a private channel and returns URL)\n# ---------------------------------------------------------------------------\nasync def upload_frame_and_get_url(\n    bot: commands.Bot,\n    pil_img: Image.Image,\n    filename: str,",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "utils.image_generator",
        "description": "utils.image_generator",
        "peekOfCode": "__all__ = [\n    \"generate_duck_game_image\",\n    \"upload_frame_and_get_url\",\n]",
        "detail": "utils.image_generator",
        "documentation": {}
    },
    {
        "label": "get_secure_hazard",
        "kind": 2,
        "importPath": "utils.rng",
        "description": "utils.rng",
        "peekOfCode": "def get_secure_hazard(total_lanes: int = 5) -> int:\n    \"\"\"\n    Return a cryptographically secure hazard lane index in [0, total_lanes-1].\n    This is lane-count aware so it works for all modes:\n      - Easy   -> total_lanes = 7\n      - Medium -> total_lanes = 5\n      - Hard   -> total_lanes = 3\n    Notes:\n    - The finish lane is NOT part of this range. Callers should treat the\n      finish (with graphic at /assets/road/end.png) as the lane AFTER the",
        "detail": "utils.rng",
        "documentation": {}
    },
    {
        "label": "DuckGameView",
        "kind": 6,
        "importPath": "views.duck_view",
        "description": "views.duck_view",
        "peekOfCode": "class DuckGameView(...):\n    def __init__(self, ..., start_position=-1):\n        ...\n        self.position = start_position\n        # Controls: only Forward on grass (-1); add Stop once on first lane or beyond\n        self.forward_button = Button(label=\"Forward\", style=discord.ButtonStyle.success)\n        self.forward_button.callback = self.forward_button_callback\n        self.add_item(self.forward_button)\n        self.stop_button = Button(label=\"Stop\", style=discord.ButtonStyle.danger)\n        self.stop_button.callback = self.stop_button_callback",
        "detail": "views.duck_view",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "bot",
        "description": "bot",
        "peekOfCode": "log = logging.getLogger(\"duckbot\")\n# Load token from .env (expects DISCORD_TOKEN=...)\nload_dotenv()\nTOKEN = os.getenv(\"DISCORD_TOKEN\")\nANNOUNCE_CHANNEL_ID = 1403244656845787170  # optional announce channel\nif not TOKEN:\n    raise RuntimeError(\"DISCORD_TOKEN is missing. Put it in a .env file or environment variable.\")\n# Intents\nintents = discord.Intents.default()\nintents.message_content = True  # needs to be enabled in Dev Portal for your bot",
        "detail": "bot",
        "documentation": {}
    },
    {
        "label": "TOKEN",
        "kind": 5,
        "importPath": "bot",
        "description": "bot",
        "peekOfCode": "TOKEN = os.getenv(\"DISCORD_TOKEN\")\nANNOUNCE_CHANNEL_ID = 1403244656845787170  # optional announce channel\nif not TOKEN:\n    raise RuntimeError(\"DISCORD_TOKEN is missing. Put it in a .env file or environment variable.\")\n# Intents\nintents = discord.Intents.default()\nintents.message_content = True  # needs to be enabled in Dev Portal for your bot\nintents.members = True\n# Bot instance\nbot = commands.Bot(command_prefix=\"!\", intents=intents)",
        "detail": "bot",
        "documentation": {}
    },
    {
        "label": "ANNOUNCE_CHANNEL_ID",
        "kind": 5,
        "importPath": "bot",
        "description": "bot",
        "peekOfCode": "ANNOUNCE_CHANNEL_ID = 1403244656845787170  # optional announce channel\nif not TOKEN:\n    raise RuntimeError(\"DISCORD_TOKEN is missing. Put it in a .env file or environment variable.\")\n# Intents\nintents = discord.Intents.default()\nintents.message_content = True  # needs to be enabled in Dev Portal for your bot\nintents.members = True\n# Bot instance\nbot = commands.Bot(command_prefix=\"!\", intents=intents)\n# If you override help elsewhere",
        "detail": "bot",
        "documentation": {}
    },
    {
        "label": "intents",
        "kind": 5,
        "importPath": "bot",
        "description": "bot",
        "peekOfCode": "intents = discord.Intents.default()\nintents.message_content = True  # needs to be enabled in Dev Portal for your bot\nintents.members = True\n# Bot instance\nbot = commands.Bot(command_prefix=\"!\", intents=intents)\n# If you override help elsewhere\nbot.remove_command(\"help\")\n_has_announced = False\n@bot.event\nasync def on_ready():",
        "detail": "bot",
        "documentation": {}
    },
    {
        "label": "intents.message_content",
        "kind": 5,
        "importPath": "bot",
        "description": "bot",
        "peekOfCode": "intents.message_content = True  # needs to be enabled in Dev Portal for your bot\nintents.members = True\n# Bot instance\nbot = commands.Bot(command_prefix=\"!\", intents=intents)\n# If you override help elsewhere\nbot.remove_command(\"help\")\n_has_announced = False\n@bot.event\nasync def on_ready():\n    global _has_announced",
        "detail": "bot",
        "documentation": {}
    },
    {
        "label": "intents.members",
        "kind": 5,
        "importPath": "bot",
        "description": "bot",
        "peekOfCode": "intents.members = True\n# Bot instance\nbot = commands.Bot(command_prefix=\"!\", intents=intents)\n# If you override help elsewhere\nbot.remove_command(\"help\")\n_has_announced = False\n@bot.event\nasync def on_ready():\n    global _has_announced\n    log.info(\"Logged in as %s (ID: %s)\", bot.user, bot.user.id)",
        "detail": "bot",
        "documentation": {}
    },
    {
        "label": "bot",
        "kind": 5,
        "importPath": "bot",
        "description": "bot",
        "peekOfCode": "bot = commands.Bot(command_prefix=\"!\", intents=intents)\n# If you override help elsewhere\nbot.remove_command(\"help\")\n_has_announced = False\n@bot.event\nasync def on_ready():\n    global _has_announced\n    log.info(\"Logged in as %s (ID: %s)\", bot.user, bot.user.id)\n    # Avoid announcing multiple times on reconnects\n    if _has_announced:",
        "detail": "bot",
        "documentation": {}
    },
    {
        "label": "_has_announced",
        "kind": 5,
        "importPath": "bot",
        "description": "bot",
        "peekOfCode": "_has_announced = False\n@bot.event\nasync def on_ready():\n    global _has_announced\n    log.info(\"Logged in as %s (ID: %s)\", bot.user, bot.user.id)\n    # Avoid announcing multiple times on reconnects\n    if _has_announced:\n        return\n    channel = bot.get_channel(ANNOUNCE_CHANNEL_ID)\n    if channel is None:",
        "detail": "bot",
        "documentation": {}
    }
]